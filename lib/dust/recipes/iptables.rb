require 'ipaddress'

class Iptables < Thor
  desc 'iptables:deploy', 'configures iptables firewall'
  def deploy node, rules, options
    template_path = "./templates/#{ File.basename(__FILE__).chomp( File.extname(__FILE__) ) }"

    # install iptables
    if node.uses_apt? or node.uses_emerge?
      node.install_package 'iptables'

    elsif node.uses_rpm?
      node.install_package 'iptables-ipv6'

    else
      ::Dust.print_failed 'os not supported'
      return 
    end


    [ 'iptables', 'ip6tables' ].each do |iptables|
      if iptables == 'iptables'
        ipv = 4
        ipv4 = true
        ipv6 = false
      elsif iptables == 'ip6tables'
        ipv = 6
        ipv4 = false
        ipv6 = true
      end

      ::Dust.print_msg "configuring and deploying ipv4 rules\n" if ipv4
      ::Dust.print_msg "configuring and deploying ipv6 rules\n" if ipv6

      iptables_filter = '' 
      iptables_nat = '' if node.uses_rpm?

      # default policy for chains
      if node.uses_apt? or node.uses_emerge?
        iptables_filter += rules['input'] ? "-P INPUT DROP\n" : "-P INPUT ACCEPT\n"
        iptables_filter += rules['output'] ? "-P OUTPUT DROP\n" : "-P OUTPUT ACCEPT\n"
        iptables_filter += rules['forward'] ? "-P FORWARD DROP\n" : "-P FORWARD ACCEPT\n"

        iptables_filter += "-F\n"
        iptables_filter += "-F -t nat\n" if ipv4
        iptables_filter += "-X\n"

      elsif node.uses_rpm?
        iptables_filter += "*filter\n"

        iptables_filter += rules['input'] ? ":INPUT DROP [0:0]\n" : ":INPUT ACCEPT [0:0]\n"
        iptables_filter += rules['output'] ? ":OUTPUT DROP [0:0]\n" : ":OUTPUT ACCEPT [0:0]\n"
        iptables_filter += rules['forward'] ? ":FORWARD DROP [0:0]\n" : ":FORWARD ACCEPT [0:0]\n"

        # also create a *nat element, centos-like systems need that.
        if ipv4
          iptables_nat  += "*nat\n"
          iptables_nat  += ":PREROUTING ACCEPT [0:0]\n"
          iptables_nat  += ":POSTROUTING ACCEPT [0:0]\n"
          iptables_nat  += ":OUTPUT ACCEPT [0:0]\n"
        end
      end

      # map rules to iptables strings
      rules.each do |chain, chain_rules|
        ::Dust.print_msg "#{::Dust.pink}#{chain.upcase}#{::Dust.none}\n", :indent => 2
        chain_rules.sort.each do |name, rule|
          # set default variables
          rule['jump'] ||= ['ACCEPT']

          # if we want to use ports, we're going to need a protocol. defaulting to tcp
          rule['protocol'] ||= ['tcp'] if rule['dport'] or rule['sport']

          # convert non-array variables to array, so we won't get hickups when using .each and .combine
          rule.each { |k, v| rule[k] = [ rule[k] ] unless rule[k].is_a? Array }

          next unless check_ipversion rule, ipv

          # on centos-like machines, nat tables are handled differently
          # remove --table argument and 
          is_nat = false
          if node.uses_rpm? and rule['table']
            rule.delete 'table'
            is_nat = true
          end

          parse_rule(rule).each do |r|
            # TODO: parse nicer output
            ::Dust.print_msg "#{name}:#{::Dust.grey 0} '#{r.join ' ' }'#{::Dust.none}\n", :indent => 3

            if is_nat
              # handle centos special case
              iptables_nat += "-A #{chain.upcase} #{r.join ' '}\n" 
            else
              iptables_filter += "-A #{chain.upcase} #{r.join ' '}\n"
            end
          end
        end
      end

      # put commit statement for rpm machines
      if node.uses_rpm?
        iptables_filter += "COMMIT\n"
        iptables_nat += "COMMIT\n" if ipv4
      end

      # prepend iptables command on non-centos-like machines
      if node.uses_apt? or node.uses_emerge?
        iptables_filter = iptables_filter.map { |s| "#{iptables} #{s}" }.to_s
      end

      # set header
      header  = ''
      if node.uses_apt? or node.uses_emerge?
        header  = "#!/bin/sh\n"
      end
      header += "# automatically generated by dust\n\n"
      iptables_filter = header + iptables_filter

      # append nat table to filter
      iptables_filter = iptables_filter + iptables_nat if node.uses_rpm? and ipv4

      # set the target file depending on distribution
      target = "/etc/network/if-pre-up.d/#{iptables}" if node.uses_apt?
      target = "/etc/#{iptables}" if node.uses_emerge?
      target = "/etc/sysconfig/#{iptables}" if node.uses_rpm?

      node.write target, iptables_filter, :quiet => true

      if node.uses_apt? or node.uses_emerge?
        node.chmod '700', target
      elsif node.uses_rpm?
        node.chmod '600', target
      end

      if options.restart?
        ::Dust.print_msg 'applying ipv4 rules' if ipv4
        ::Dust.print_msg 'applying ipv6 rules' if ipv6

        if node.uses_rpm?
          ::Dust.print_result node.exec("/etc/init.d/#{iptables} restart")[:exit_code]

        elsif node.uses_apt? or node.uses_emerge?
          ret = node.exec target
          ::Dust.print_result( (ret[:exit_code] == 0 and ret[:stdout].empty? and ret[:stderr].empty?) )
        end
      end

      # on gentoo, rules have to be saved using the init script,
      # otherwise they won't get re-applied on next startup
      if node.uses_emerge?
        ::Dust.print_msg 'saving ipv4 rules' if ipv4
        ::Dust.print_msg 'saving ipv6 rules' if ipv6
        ::Dust.print_result node.exec("/etc/init.d/#{iptables} save")[:exit_code]
      end

      puts
    end
  end


  private 

  # check if source and destination ip (if given)
  # are valid ips for this ip version
  def check_ipversion rule, ipv
    ['source', 'src', 'destination', 'dest', 'to-source'].each do |attr|
      if rule[attr]
        rule[attr].each do |addr|
          return false unless IPAddress(addr).send "ipv#{ipv}?"
        end
      end
      # return false if this ip version was manually disabled
      return false unless rule['ip-version'].include? ipv if rule['ip-version']
    end
    true
  end

  # map iptables options
  def parse_rule r
    with_dashes = {}
    result = []

    r.each do |k, v|
      next if k == 'ip-version' # skip ip-version, since its not iptables option
      with_dashes[k] = r[k].map do |v|
        value = v.to_s
        if value.start_with? '!', '! '
          # map '--key ! value' to '! --key value'
          value.slice! '!' 
          value.lstrip!
          "! --#{k} #{value}"
        else
          "--#{k} #{value}"
        end
      end
    end
    with_dashes.values.each { |a| result = result.combine a }

    # make sure the options are sorted in a way that works.
    sorted = []
    result.each do |r|
      # sort rules so it makes sense
      r = r.sort_by do |x|
        if x.include? '--match'
          -1
        elsif x.include? '--protocol'
          -2
        elsif x.include? '--jump'
          1
        elsif x.include? '--to-port'
          2
        elsif x.include? '--to-destination'
          3
        elsif x.include? '--to-source'
          4
        elsif x.include? '--ttl-set'
          5
        elsif x.include? '--clamp-mss-to-pmtu'
          6
        elsif x.include? '--reject-with'
          7
        else
          0
        end
      end
      sorted.push r
    end

    sorted
  end
end

