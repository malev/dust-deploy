require 'ipaddress'

class Iptables < Thor
  desc 'iptables:deploy', 'configures iptables firewall'
  def deploy node, rules, options
    template_path = "./templates/#{ File.basename(__FILE__).chomp( File.extname(__FILE__) ) }"

    # install iptables
    if node.uses_apt? true or node.uses_emerge? true
      node.install_package 'iptables'

    elsif node.uses_rpm? true
      node.install_package 'iptables-ipv6'

    else
      ::Dust.print_failed 'os not supported'
      return 
    end


    [ 'iptables', 'ip6tables' ].each do |iptables|
      if iptables == 'iptables'
        ipv = 4
        ipv4 = true
        ipv6 = false
      elsif iptables == 'ip6tables'
        ipv = 6
        ipv4 = false
        ipv6 = true
      end

      ::Dust.print_msg "configuring and deploying ipv4 rules\n" if ipv4
      ::Dust.print_msg "configuring and deploying ipv6 rules\n" if ipv6

      iptables_script = '' 

      # default policy for chains
      if node.uses_apt? true or node.uses_emerge? true
        iptables_script += rules['input'] ? "-P INPUT DROP\n" : "-P INPUT ACCEPT\n"
        iptables_script += rules['output'] ? "-P OUTPUT DROP\n" : "-P OUTPUT ACCEPT\n"
        iptables_script += rules['forward'] ? "-P FORWARD DROP\n" : "-P FORWARD ACCEPT\n"

        iptables_script += "-F\n"
        iptables_script += "-F -t nat\n" if ipv4
        iptables_script += "-X\n"

      elsif node.uses_rpm? true
        iptables_script += "*filter\n"

        iptables_script += rules['input'] ? ":INPUT DROP [0:0]\n" : ":INPUT ACCEPT [0:0]\n"
        iptables_script += rules['output'] ? ":OUTPUT DROP [0:0]\n" : ":OUTPUT ACCEPT [0:0]\n"
        iptables_script += rules['forward'] ? ":FORWARD DROP [0:0]\n" : ":FORWARD ACCEPT [0:0]\n"
      end

      # map rules to iptables strings
      rules.each do |chain, chain_rules|
        ::Dust.print_msg "#{::Dust.pink}#{chain.upcase}#{::Dust.none}\n", 2
        chain_rules.sort.each do |name, rule|
          # set default variables
          rule['jump'] ||= ['ACCEPT']

          # if we want to use ports, we're going to need a protocol. defaulting to tcp
          rule['protocol'] ||= ['tcp'] if rule['dport'] or rule['sport']

          # convert non-array variables to array, so we won't get hickups when using .each and .combine
          rule.each { |k, v| rule[k] = [ rule[k] ] if rule[k].class != Array }

          next unless check_ipversion rule, ipv

          parse_rule(rule).each do |r|
            # TODO: parse nicer output
            ::Dust.print_msg "#{name}:#{::Dust.grey 0} '#{r.join ' ' }'#{::Dust.none}\n", 3
            iptables_script += "-A #{chain.upcase} #{r.join ' '}\n"
          end
        end
      end

      # put commit statement for rpm machines
      iptables_script += "COMMIT\n" if node.uses_rpm? true

      # prepend iptables command on non-centos-like machines
      iptables_script = iptables_script.map { |s| "#{iptables} #{s}" }.to_s if node.uses_apt? true or node.uses_emerge? true

      # set header
      header  = ''
      header  = "#!/bin/sh\n" if node.uses_apt? true or node.uses_emerge? true
      header += "# automatically generated by dust\n\n"
      iptables_script = header + iptables_script

      # set the target file depending on distribution
      target = "/etc/network/if-pre-up.d/#{iptables}" if node.uses_apt? true
      target = "/etc/#{iptables}" if node.uses_emerge? true
      target = "/etc/sysconfig/#{iptables}" if node.uses_rpm? true

      node.write target, iptables_script, true

      node.chmod '700', target if node.uses_apt? true or node.uses_emerge? true
      node.chmod '600', target if node.uses_rpm? true

      if options.restart?
        ::Dust.print_msg 'applying ipv4 rules' if ipv4
        ::Dust.print_msg 'applying ipv6 rules' if ipv6

        if node.uses_rpm? true
          ::Dust.print_result node.exec("/etc/init.d/#{iptables} restart")[:exit_code]

        elsif node.uses_apt? true or node.uses_emerge? true
          ret = node.exec target
          ::Dust.print_result( (ret[:exit_code] == 0 and ret[:stdout].empty? and ret[:stderr].empty?) )
        end
      end

      # on gentoo, rules have to be saved using the init script,
      # otherwise they won't get re-applied on next startup
      if node.uses_emerge? true
        ::Dust.print_msg 'saving ipv4 rules' if ipv4
        ::Dust.print_msg 'saving ipv6 rules' if ipv6
        ::Dust.print_result node.exec("/etc/init.d/#{iptables} save")[:exit_code]
      end

      puts
    end
  end


  private 

  # check if source and destination ip (if given)
  # are valid ips for this ip version
  def check_ipversion rule, ipv
    ['source', 'src', 'destination', 'dest', 'to-source'].each do |attr|
      if rule[attr]
        rule[attr].each do |addr|
          return false unless IPAddress(addr).send "ipv#{ipv}?"
        end
      end
      # return false if this ip version was manually disabled
      return false unless rule['ip-version'].include? ipv if rule['ip-version']
    end
    true
  end

  # map iptables options
  def parse_rule r
    with_dashes = {}
    result = []

    r.each do |k, v|
      next if k == 'ip-version' # skip ip-version, since its not iptables option
      with_dashes[k] = r[k].map do |v|
        value = v.to_s
        if value.start_with? '!', '! '
          # map '--key ! value' to '! --key value'
          value.slice! '!' 
          value.lstrip!
          "! --#{k} #{value}"
        else
          "--#{k} #{value}"
        end
      end
    end
    with_dashes.values.each { |a| result = result.combine a }

    # make sure the options are sorted in a way that works.
    sorted = []
    result.each do |r|
      # bring to the front
      r = r.sort_by { |x| if x.include? '--match' then -1 else 1 end }
      r = r.sort_by { |x| if x.include? '--protocol' then -1 else 1 end }
      # shift to the end
      r = r.sort_by { |x| if x.include? '--jump' then 1 else -1 end }
      r = r.sort_by { |x| if x.include? '--to-port' then 1 else -1 end }
      r = r.sort_by { |x| if x.include? '--to-destination' then 1 else -1 end }
      r = r.sort_by { |x| if x.include? '--to-source' then 1 else -1 end }
      r = r.sort_by { |x| if x.include? '--ttl-set' then 1 else -1 end }
      r = r.sort_by { |x| if x.include? '--clamp-mss-to-pmtu' then 1 else -1 end }
      r = r.sort_by { |x| if x.include? '--reject-with' then 1 else -1 end }
      sorted.push r
    end

    sorted
  end
end

