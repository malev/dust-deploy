#!/usr/bin/env ruby

require 'rubygems'
require 'thor/runner'
require 'thor/util'
require 'yaml'
require 'fileutils'
require 'dust'

module  Dust
  class Deploy < Thor::Runner

    default_task :list

    desc 'deploy [server.yaml] [--filter key=value,value2] [--recipes recipe1 recipe2] [--proxy host:port]',
         'deploy all recipes to the node(s) specified in server.yaml or to all nodes defined in ./nodes/'

    method_options :filter => :hash, :recipes => :array, :proxy => :string,
                   :restart => :boolean, :reload => :boolean

    def deploy yaml=''
      return unless check_dust_dir
      initialize_thorfiles
      Dust.print_failed 'no servers match this filter' if load_servers(yaml).empty?

      run_recipes 'deploy'
    end


    desc 'status [server.yaml] [--filter key=value,value2] [--recipes recipe1 recipe2] [--proxy host:port]',
         'display status of recipes specified by filter'

    method_options :filter => :hash, :recipes => :array, :proxy => :string

    def status yaml=''
      return unless check_dust_dir
      initialize_thorfiles
      Dust.print_failed 'no servers match this filter' if load_servers(yaml).empty?

      run_recipes 'status'
    end


    # creates directory skeleton for a dust setup
    desc 'new <name>', 'creates a dust directory skeleton for your network'
    def new name
      Dust.print_msg "spawning new dust directory skeleton with examples into '#{name}.dust'"
      FileUtils.cp_r File.dirname(__FILE__) + '/../lib/dust/examples', "#{name}.dust"
      Dust.print_ok
    end


    private

    def check_dust_dir
      if Dir.pwd.split('.').last != 'dust'
        Dust.print_failed 'current directory does not end with .dust, are you in your dust directory?'
        Dust.print_msg "try running 'dust new mynetwork' to let me create one for you with tons of examples!\n", 0
        return false
      end

      unless File.directory? './nodes'
        Dust.print_failed 'could not find \'nodes\' folder in your dust directory. cannot continue.'
        return false
      end

      true
    end

    # run specified recipes in the given context
    def run_recipes context
      @nodes.each do |node|
        # skip this node if there are no recipes found
        next unless node['recipes']
          
        recipes = generate_recipes node, context

        # skip this node unless we're actually having recipes to cook
        next if recipes.empty?

        # connect to server
        server = Server.new node
        next unless server.connect

        # runs the method with the recipe name, defined and included in recipe/*.rb
        # call recipes for each recipe that is defined for this node
        recipes.each do |recipe, ingredients|
          ::Dust.print_recipe recipe
          send recipe, context, server, ingredients, options
          puts
        end

        server.disconnect
      end
    end
    
    # generate list of recipes for this node
    def generate_recipes node, context
      recipes = {}  
      node['recipes'].each do |recipe, ingredients|
      
        # in case --recipes was set, skip unwanted recipes
        next unless options[:recipes].include?(recipe) if options[:recipes]
      
        # skip disabled recipes
        next if ingredients == 'disabled'
      
        # check if method and thor task actually exist
        k = Thor::Util.find_by_namespace recipe
        next unless k
        next unless k.method_defined? context
      
        recipes[recipe] = ingredients
      end
      recipes
    end
    

    # overwrite thorfiles to look for tasks in the recipes directories
    def thorfiles(relevant_to=nil, skip_lookup=false)
      Dir[File.dirname(__FILE__) + '/../lib/dust/recipes/*.rb'] | Dir['recipes/*.rb']
    end

    # loads servers
    def load_servers yaml=''
      @nodes = []

      # if the argument is empty, load all yaml files in the ./nodes/ directory
      # if the argument is a directory, load yaml files in this directory
      # if the argument is a file, load the file.
      if yaml.empty?
        yaml_files = Dir['./nodes/**/*.yaml']
      else
        yaml_files = Dir["#{yaml}/**/*.yaml"] if File.directory? yaml
        yaml_files = yaml if File.exists? yaml
      end

      unless yaml_files
        Dust.print_failed "#{yaml} doesn't exist. exiting."
        exit
      end

      yaml_files.each do |file|
        node = YAML.load_file(file)

        # if the file is empty, just skip it
        next unless node

        # if there is not hostname field in the yaml file,
        # treat this node file as a template, and skip to the next one
        next unless node['hostname']
  
        # look for the inherits field in the yaml file,
        # and merge the templates recursively into this node
        if node['inherits']
          inherited = {}
          node.delete('inherits').each do |file|
            template = YAML.load_file "./nodes/#{file}.yaml"
            inherited.deep_merge! template
          end
          node = inherited.deep_merge node
        end

        # if more than one hostname is specified, create a node
        # with the same settings for each hostname
        node['hostname'].each do |hostname|
          n = node.clone

          # overwrite hostname with single hostname (in case there are multiple)
          n['hostname'] = hostname

          # create a new field with the fully qualified domain name
          n['fqdn'] = hostname
          n['fqdn'] += '.' + n['domain'] if n['domain']

          # pass command line proxy option
          n['proxy'] = options[:proxy] if options[:proxy]

          # add this node to the global node array
          @nodes.push n unless filtered? n
        end
      end
    end

    # checks if this node was filtered out by command line argument
    # e.g. --filter environment:staging filters out all machines but
    # those in the environment staging
    def filtered? node

      # if filter is not specified, instantly return false
      return false unless options[:filter]

      # remove items if other filter arguments don't match
      options[:filter].each do |k, v|
        next unless v # skip empty filters

        # filter if this node doesn't even have the attribute
        return true unless node[k]

        # allow multiple filters of the same type, divided by ','
        # e.g. --filter environment:staging,production
        return true unless v.split(',').include? node[k]
      end

      # no filter matched, so this host is not filtered.
      false
    end
  end

  Deploy.start
end
